import requests
import streamlit as st
from qdrant_client import QdrantClient
from openai import OpenAI
import os
from streamlit_star_rating import st_star_rating

os.environ["TOKENIZERS_PARALLELISM"] = "false"

openai_api_key = st.secrets['OPENAI_API_KEY']
qdrant_api_key = st.secrets['qdrant_api_key']
qdrant_url = "https://qdrant.utvecklingfalkenberg.se"
collection_name = "KFT_knowledge_base_OpenAI_Large_chunk1000"
directus_api_url = "https://nav.utvecklingfalkenberg.se/items/kft_bot"
directus_params={"access_token":st.secrets['directus_token']}

openai_client = OpenAI(api_key=openai_api_key)
qdrant_client = QdrantClient(url=qdrant_url, port=443, https=True, api_key=qdrant_api_key)

def generate_embeddings(text):
    response = openai_client.embeddings.create(input=text, model="text-embedding-3-large")
    return response.data[0].embedding

def search_collection(qdrant_client, collection_name, user_query_embedding):
    response = qdrant_client.search(collection_name=collection_name, query_vector=user_query_embedding, limit=5, with_payload=True) #score_threshold=0.4)
    return response

def get_chat_response_streaming(user_message, extra_knowledge, instructions_prompt, model="gpt-4-turbo-preview", client=None):
    if client is None:
        client = OpenAI(api_key=openai_api_key)
    full_response = ""
    message_placeholder = st.empty()
    completion = client.chat.completions.create(model=model, messages=[{"role": "system", "content": instructions_prompt}], stream=True)
    for chunk in completion:
        st.session_state['response_completed']=False
        if chunk.choices[0].finish_reason == "stop":
            st.session_state['response_completed']=True
            message_placeholder.markdown(full_response)
                # directus post    
            data={"prompt":user_message, "instruction_prompt": extra_knowledge, "response": full_response}
            directus_response = requests.post(directus_api_url, json=data, params=directus_params)
            if directus_response.status_code == 200:
                response_data = directus_response.json()
                st.session_state['record_id'] = response_data['data']['id']  # Save the record ID for later update
                # st.success("Tack f√∂r din feedback!")
                print(st.session_state['record_id'])
            else:
                st.error("N√•got gick fel. F√∂rs√∂k igen senare.")
            return full_response
        full_response += chunk.choices[0].delta.content
        message_placeholder.markdown(full_response + "‚ñå")




def format_output(similar_texts, answer):
    text = f"Generated Response:\n{answer}\n\nSimilar Texts Found:\n"
    for index, (text_content, source, score) in enumerate(similar_texts):
        text += f"Resultat {index + 1} - K√§lla: {source}, Tr√§ffs√§kerhet: {score}, Text: {text_content}\n"
    return text

st.title("Demo KFT - utkastsgenererare")
# st.write(collection_name)
with st.form(key='user_query_form', clear_on_submit=True):
    user_input = st.text_input("Klistra in fr√•ga/klagom√•l fr√•n inv√•nare h√§r:", key="user_input")
    st.caption("Svaren genereras av en AI-bot, som kan beg√• misstag. Fr√•gor och svar lagras i utvecklingssyfte. Skriv inte personuppgifter i f√§ltet.")
    extra_knowledge = st.text_input("Klistra in extra kontext/kunskap/fakta/instruktioner h√§r:", key="extra_knowledge")
    input_to_embed = user_input + extra_knowledge
    submit_button = st.form_submit_button("Genera utkast till svar ü™Ñ")

if submit_button and user_input:
    user_embedding = generate_embeddings(input_to_embed)
    search_results = search_collection(qdrant_client, collection_name, user_embedding)
    similar_texts = [(result.payload['text'], result.payload['file_source'], result.score) for result in search_results]
    
    if similar_texts:
        with st.expander("Se relevanta k√§llor"):
            for index, (text, source, score) in enumerate(similar_texts):
                st.write(f"Resultat {index + 1}:")
                st.write("K√§lla:", source)
                st.write("Tr√§ffs√§kerhet:", score)
                st.write(f"Text fr√•n dokument:\n{text}")
                st.write("---")

    # Construct an instructions prompt using the user input and search results
    instructions_prompt = f"""
    Givet denna inv√•nar-fr√•ga: '{user_input}', samt om det finns ytterligare information fr√•n anst√§lld i kommunen 'extra-instruktioner':{extra_knowledge}, samt kontexten fr√•n en databas: {[result.payload['text'] for result in search_results]}, sammanst√§ll relevant fakta p√• ett l√§ttl√§st s√§tt, samt ge ett utkast p√• hur ett svar skulle kunna se ut. Ditt svar riktas till en anst√§lld p√• kommunen och skall utg√∂ra ett st√∂d f√∂r den anst√§llde att √•terkoppla direkt till den som st√§ller fr√•gan. Inneh√•ller {user_input} b√•de en fr√•ga och synpunkt eller klagom√•l, adressera du b√•da utifr√•n din fakta. Om du har f√•tt r√§tt kontext i form av fakta f√∂r att ge ett korrekt svar s√• skriver du det, om inte s√• skriver du att kommunen har tagit emot synpunkten och diarief√∂rt den men att det inte √§r s√§kert att det finns resurser att prioritera just denna fr√•ga. Inkludera k√§lla f√∂r ditt svar. Svara v√§nligt men kortfattat.

    Ditt svar b√∂rjar med: 'Hej Namn', avslutas med: 'Med v√§nliga h√§lsningar, [Namn], [Avdelning p√• kommunen]
    """

    answer = get_chat_response_streaming(user_input, extra_knowledge, instructions_prompt)

if 'response_completed' in st.session_state and st.session_state['response_completed']:

    with st.form(key='user_feedback_form', clear_on_submit=True):
        stars = st_star_rating("Hur n√∂jd √§r du med svaret", maxValue=5, defaultValue=3, key="rating")
        user_feedback = st.text_area("Vad var bra/mindre bra?")
        feedback_submit_button = st.form_submit_button("Skicka")
        print(user_input)

    if feedback_submit_button and user_input:
        print(st.session_state['record_id'])
        if 'record_id' in st.session_state and st.session_state['record_id']:
            update_data = {"user_rating": stars, "user_feedback": user_feedback}
            update_url = f"{directus_api_url}/{st.session_state['record_id']}"
            headers = {"Content-Type": "application/json"}
            params = {"access_token": st.secrets["directus_token"]}
            print(update_url)
            print(user_input)

            update_response = requests.patch(update_url, json=update_data, headers=headers, params=params)

            if update_response.status_code == 200:
                st.success("Tack f√∂r din feedback!")
                st.session_state['response_completed'] = False
                st.rerun()
            else:
                st.error("N√•got gick fel. Tack f√∂r din feedback!")

        


